## 作用域
    概念：通常来说，一段程序所用到的名字（变量或函数）从定义的结束标签中间的区域就是作用域
    简单理解：代码的名字可以在某个区域中使用
- es5 
    全局作用域 ：一个html中一对script就是一个全局作用域  或   1个js文件就是一个全局作用域
    局部作用域 ：又名函数作用域
    
    **区别**：
        - 全局作用域中的变量会在关闭浏览器的时候后释放
        - 局部作用域中变量会在函数执行完毕之后被释放(删除变量)

    题外话 面试前看看
    - 释放：是内存中删除变量
    - 垃圾回收机制(标记清除(常见)，引用计数)


- es6 块级作用域
    一个大括号里面的内容就是块级作用域
```
// 块级作用域
        if (true) {
            let a = 1;
            console.log(a);
        }
        console.log(a);
```
```
局部作用域
var a = 1;
        function fn () {
            // 函数体内部就是局部作用域
            var b = 2;
            console.log(b);
            // 函数执行完毕
        }
        fn()
        console.log(b);//b 没有定义
```

- 作用域链：是变量上级作用访问的过程
    规则：执行变量相关操作的时候，先找自己的作用域的。如果没有再往上一层作用域查找，如果没有再向上，直到找到全局为止；如果全局没有直接报错
```
 var z = 10;
        function baba () {
            function son () {
                console.log(z);
            }
            son()
        }
        baba()
```

### 面试题
作用域链：闭包（重要 重点）
**三座大山**
1.作用域与闭包  js基础
2.同步与异步    js进阶
3.对象与原型    js面向对象



## 闭包
    1.概念：闭包是一个函数，它是函数中的特殊应用
        就是 一个有权访问(按照作用域链的机制)另外一个一个函数的作用域  的  函数
    2.使用场景：
        两种
        1.)函数作为参数被传递
        2.)函数作为返回值被返回
        上述两种场景，关键在于都要看函数定义的地方，变量向上级查找，不要看函数调用的地方
    3.闭包的特点
        闭包中使用的变量是不会被内存释放的
        一直到关闭浏览器才会释放
    **注意**：局部变量不会因为不被释放从而变成全局
    **缺点**：造成内存泄漏
    4.实际场景中
        1.)将数据(变量) 私有化 (变成局部)
            作用：防止外部对数据进行读写操作
        2.)后续回来补充
        立刻执行函数  语法：
        /*
        (function () {
           函数体
        }())
        */

```
        // 函数作为参数被传递
        function fn (b) {
            var a = 200;
            b()
        }
        var a = 100;
        function fn1 () {
            console.log(a);
        }
        fn(fn1)

        // 函数作为返回值被返回
        function fn2 () {
            var b = 200;
            return function () {
                console.log(b);
            }
        }
        var b = 100;
        var c = fn2();
        c()
```

## 预解析
    1.概念
    1.1解析代码(预编译、预解析)
        将关键字 var function  的内容提前到script标签的最上方
        这样提升的过程，称为 代码的预解析 机制
    1.2执行代码

    2.学会如何去解析(了解js的解析机制)
    2.1 var 提升机制
        2.1-1 全局var 提升
        2.1-2 局部var 中
            显式提升
                如果变量没有关键字var 那么将会变成全局变量
                如果变量有var 那么将会提升到函数顶部 依旧局部
            隐式提升
                 var x = y = 1; => 局部 var x =1； 全局y =1
    3.关键字function 提升
        不同名：提升即可
        同名 ：遵循就近原则

        var 和 function  都同名的情况下
        var 和函数都会提升 通过赋值覆盖了函数 所以报错
        ```
         // var m;
        // function m () {
        // console.log(22);
        // }
        var m = 1;
        function m () {
            console.log(22);
        }
        m()//m=1   =>1()
        ```


```
// var a;//js预解析 解析出来
        function fn () {
            // 如果在函数内部没有有var 去声明一个变量
            // 该变量会被系统自动做一个提升的操作
            // 在代码执行前，先在script开始的时候  自动在全局补充  var a；
            a = 1;//赋值操作 是赋值给全局的 a
            console.log(a);


            var b = 2;
            console.log(b);
        }
        fn()
        console.log(a);


// 隐式提升
        //var y;
        function fn () {
            // var x;
            var x = y = 1;//var x =1  var y =1 错
            console.log(x, y);
        }
        fn()
        // console.log(x, y);//报错
        console.log(y);//1
```


## let
### var 关键字预编译
- 但是在实际开发中完全不用var
- 根本不用考虑变量问题
- es6 之后声明变量的关键字var => lrt const

### let 定义可以修改的变量
### const 常量  定义不可修改的变量