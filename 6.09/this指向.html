<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>this指向问题</title>
</head>

<body>
    <!-- 
        一.this指向
    所有编程的语言中，都会出现this
    this也是所有编程语言中比较麻烦
    为什么？
    就近原则。this 上下文 （作用域）
    作用？
    方便程序在多种环境下执行。

    this指向的结论;
    1.普通函数在script中调用 this指向window
    2.当一个函数在对象内部时，该对象调用该函数，该this指向该对象
    3.当一个函数在对象内部，函数赋值给全局变量w,再调用函数，该this指向就指向window
    4.当一个函数在对象方法中定义，该函数被视为普通函数，回到结论1 this就会指向window

    总结：
    谁调用这个函数，this就会指向谁
    定时器中的函数中的this的指向永远都是window的 -->
    <!-- <input type="text" class="ipt">
    <input type="text" class="ipt1"> -->

    <!-- 二.this指向的改变
    call(),apply(),bind()
    备注：可以定义 that 来保存this指向（不推荐） -->



    <!-- 三.箭头函数
    是什么？
    本质上也是一个函数，是普通函数的升级版的写法(更加简洁)

    1.语法结构
    - 写法1
    let 函数名 = (参数) => {函数体}
    - 写法2：当参数只有一个的时候，括号可省
    当没有参数或者多个参数的时候，括号不能省略
    let 函数名 = 参数 => {函数体}
    let 函数名 = （参数1，参数2） => {函数体}

    - 写法3：函数带返回值
    return 和 {} 都可以省略
    let 函数名 = 参数 => 函数体 -->

    2.学会判断箭头函数的this指向


    <script>
        var a = 2
        let obj = {
            a: 1,
            fn: function () {
                // 1.this 是写在箭头函数中
                // 2.this在箭头函数中是没有this指向
                // 3.看作用域  fn的作用域
                // 4.看谁调用fn,看出obj
                // 5.this 指向obj
                // 6.最终输出1
                let fn2 = () => { console.log(this.a); }//obj.a
                return fn2()
            }
        }
        obj.fn()





        // var a = 1
        // let obj = {
        //     a: 2,
        //     fn: () => {
        //         console.log(this.a);//window.a
        //     }
        // }
        // obj.fn()





        // let fn = a => {
        //     console.log(this);
        // }
        // fn()






        // function fn () {
        //     // console.log(a);
        //     return a
        // }



        // 不带返回值
        // let fn = (a,b) => {
        //     console.log(a,b);
        // }
        // let fn = a => {
        //     console.log(a);
        // }


        // 带返回值
        // 不写return 也不写{}
        // let fn = a => a
        // 如果函数体内部是多行操作就不要省略return 和  {}
        // 如果 函数体内部只有一行操作，可以省略
        // let b = fn(1)
        // console.log(b);






        // var city = '广州'
        // let obj2 = {
        //     city: '杭州'
        // }
        // let obj = {
        //     city: '上海',
        //     fn: function (msg, num) {
        //         console.log(this.city + msg + num);
        //     }
        // }
        // obj.fn('真不错')
        // // 希望 输出 广州真不错    this指向从obj  =>  window
        // // call(你要改变的目标，参数)    改变this指向

        // obj.fn.call(window, '真不错')
        // obj.fn.call(obj2, '真不错')

        // // apply()
        // obj.fn.apply(obj2, ['真不错', 100])


        // // bind() 是会返回一个函数，执行这个函数才能改变指向
        // obj.fn.bind(window, '真不错', 100)()






        // let ipt = document.querySelector('.ipt')
        // let ipt1 = document.querySelector('.ipt1')
        // function fn () {
        //     console.log(this.value);
        // }
        // ipt.addEventListener('input', fn)
        // ipt1.addEventListener('input', fn)



        // var a = 2
        // let obj = {
        //     a: 1,
        //     fn: function () {
        //         setTimeout(function () {
        //             console.log(this.a);
        //         }, 1000)
        //     }
        // }
        // obj.fn()


        // var 声明是挂载在window对象上
        // let const  不是挂载在window
        // var a = 2
        // let obj = {
        //     a: 1,
        //     fn: function () {
        //         // console.log('alex');
        //         // console.log(this);//this指向obj
        //         // // this = obj
        //         // console.log(this.a);


        //         function fn2 () {
        //             console.log(this.a);
        //         }
        //         return fn2()
        //     }
        // }
        // obj.fn()

        // let w = obj.fn
        // w()


        // console.log(obj.a);
        // console.log(obj['a']);
        // obj.fn()




        // function fn () {
        //     let a = 1
        //     console.log(a);
        //     console.log(this);
        // }
        // // window 挂上fn()
        // window.fn()
    </script>
</body>

</html>